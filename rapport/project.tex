\documentclass[11pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{natbib}
\usepackage{xfrac}
\usepackage{caption}
\usepackage{threeparttable}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{subcaption}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}

\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemme}
\newtheorem{thm}{Théorème}
\newtheorem{definition}{Définition}
\newtheorem{conj}{Conjecture}

\title{À propos du problème de finitude des (semi-)groupes d'automates}
\author{Maxime Flin \& Tristan François}

\begin{document}
\maketitle
\begin{abstract}
  Les automates de Mealy sont une extension des automates qui écrivent des mots en même temps qu'ils en lisent. En étudiant leur action sur un ensemble de mot, on peut dégager une structure de (semi-)groupe engendré par l'automate.

  Le problème qui nous intéresse ici est de pouvoir décider si un automate de Mealy engendre une structure finie ou infinie. Ce problème, qui est indécidable en général, semble abordable pour des classes d'automates plus réduites. En suivant la voie ouverte par \citeauthor{Klimann13}, nous avons essayé de généraliser son résultat en ajoutant la conjugaison à la $\mathfrak{md}$-réduction.
\end{abstract}


\section*{Introduction}
Blablabla automate

\newpage

\section{Automates de Mealy}

\subsection{Automates de Mealy et quelques constructions}

La notion d'automate de Mealy étend la simple notion d'automate en lui ajoutant une sortie en écriture.

\begin{definition}
  Un \textbf{automate de Mealy} est la donné d'un quadruplet $\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ où $\mathcal{Q}$ est l'ensemble des états de l'automate, $\Sigma$ l'alphabet sur lequel l'automate agit, $\delta$ une famille d'applications de $\mathcal{Q}$ dans $\mathcal{Q}$ indexé par $\Sigma$ qui représente les transitions entre les états et $\rho$ une famille d'applications de $\Sigma$ dans $\Sigma$ indexé par $\mathcal{Q}$ qui représente l'écriture en sortie de l'automate.
\end{definition}

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_0) {$0$};
      \node[state] (q_1) [right=of q_0] {$1$};
      \path[->]
      (q_0) edge [loop above] node {$1|0$} (q_0)
      edge node {$0|1$} (q_1)
      (q_1) edge [loop above] node {$0|0~1|1$} (q_1);
    \end{tikzpicture}
    \caption{une machine de Mealy\label{fig:example}}
  \end{center}
\end{figure}

On peut représenter l'action d'un automate de Mealy par son diagramme en croix:

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}
      \draw[->] (-1.25, 0.5) node[above] {1} to (-1.25, -0.5) node[below] {0};
      \draw[->] (-1.5, 0) node[left] {0} to (-1, 0) node[right] {0};

      \draw[->] (-0.25, 0.5) node[above] {0} to (-0.25, -0.5) node[below] {1};
      \draw[->] (-0.5, 0) to (0, 0) node[right] {1};

      \draw[->] (0.75, 0.5) node[above] {1} to (0.75, -0.5) node[below] {1};
      \draw[->] (0.5, 0) to (1, 0) node[right] {1};
    \end{tikzpicture}
    \caption{action de l'état 0 de la machine \ref{fig:example} sur le mot 101. Sont représentés horizontalement les états sucessifs et verticalement l'action de chacun de ces états sur les lettres du mot.}
  \end{center}
\end{figure}

Une autre représentation qui sera commode dans la partie \ref{sec:gen} est de le représenter par un graphe en hélice.

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
      \node[state] (q_00) {$0, 0$};
      \node[state] (q_11) [right=of q_00] {$1, 1$};
      \node[state] (q_10) [above=of q_11] {$1, 0$};
      \node[state] (q_01) [above=of q_00] {$0, 1$};
      \path[->]
      (q_00) edge node {} (q_11)
      (q_10) edge [loop above] node {} (q_10)
      (q_11) edge [loop above] node {} (q_11)
      (q_01) edge node {} (q_10);
    \end{tikzpicture}
    \caption{graphe en hélice de \ref{fig:example}}
  \end{center}
\end{figure}

\begin{definition}
  Soit $\mathcal{A}=\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ un automate de Mealy.
  \begin{enumerate}[(i)]
  \item On dit que $\mathcal{A}$ est \textbf{inversible} si $\rho_q$ est une permutation de $\Sigma$ pour tout état $q$.
  \item On dit que $\mathcal{A}$ est \textbf{réversible} si $\delta_x$ est une permuration de $\mathcal{Q}$ pour toute lettre $x$.
  \item On dit que $\mathcal{A}$ est \textbf{biréversible} s'il est inversible, réversible et que son inverse est réversible.
  \end{enumerate}
\end{definition}

\begin{definition}
  Soit $\mathcal{A}=\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ un automate de Mealy. \textbf{L'équivalence de Nérode} $\equiv$ sur $\mathcal{Q}$ est la limite de la suite de relations d'équivalences ($\equiv_k$) de plus en plus fines définies récursivement par

  \begin{align*}
    \forall p, q \in Q,\\
    p \equiv_0 q &\iff \rho_p = \rho_q \\
    \forall k \geq 0, p \equiv_{k+1}q &\iff \left(p\equiv_kq \wedge \forall x \in \Sigma,~\delta_x(p)=\delta_x(q)\right)
  \end{align*}

  Le \textbf{minimisé} de $\mathcal{A}$ est l'automate $\mathfrak{m}(\mathcal{A})=\left(\sfrac{\mathcal{Q}}{\equiv}, \Sigma, \bar{\delta}, \bar{\rho}\right)$, où pour tout $p\in\mathcal{Q}$ et $x\in\Sigma$, $\bar{\delta}_x(\bar{p}) = \bar{\delta_x(p)}$ et $\bar{\rho}_{\bar{p}} =  \rho_p$.
\end{definition}

\begin{definition}
  \label{def:produit}
  Soient $A = \left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ et $B = \left(\mathcal{Q'}, \Sigma, \delta', \rho'\right)$ deux automates sur le même alphabet. On appelle \textbf{\textit{automate produit}} la machine $\mathcal{AB} = \left(\mathcal{Q}\times\mathcal{Q'}, \Sigma, \delta'', \rho''\right)$ où

\[ \delta_x''(p, q) = (\delta_x(p), \delta_x'(q))\]
et
\[ \rho_{(p,q)}(x) = \rho_q'(\rho_p(x)). \]
\end{definition}

\begin{figure}[h!]
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \draw [->] (-0.5, 1) node[left] {$p_0$} to (0.5, 1) node[right] {$q_0$};
      \draw [->] (0, 1.5) node[above] {x} to (0, 0.5);

      \draw [->] (-0.5, -0.5) node[left] {$p_1$} to (0.5, -0.5) node[right] {$q_1$};
      \draw [->] (0, 0) node[above] {z} to (0, -1) node[below] {y};
    \end{tikzpicture}
    \caption{En haut l'automate $\mathcal{A}$ et en bas $\mathcal{B}$}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \draw [->] (-0.5, 0) node[left] {$p_0p_1$} to (0.5, 0) node[right] {$q_0q_1$};
      \draw [->] (0, 0.5) node[above] {x} to (0, -0.5) node[below] {y};
    \end{tikzpicture}
    \caption{Une flèche de l'automate $\mathcal{AB}$}
  \end{subfigure}
  \caption{Correspondance entre les flèches dans $\mathcal{AB}$ et celles de $\mathcal{A}$ et de $\mathcal{B}$}
\end{figure}


\subsection{Action sur les mots et (semi-)groupes engendrés}

\begin{definition}
  Soit $\mathcal{A}=\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ un automate de Mealy. On peut étendre l'ensemble de définition de $\rho$ à sur $\Sigma^*$ par induction comme suit.

  Soient $p\in\mathcal{Q}$, $x\in\Sigma$ et $\textbf{u}\in\Sigma^*$
  \begin{align*}
    &\rho_p(\epsilon)=\epsilon \\
    &\rho_p(x\textbf{u})=\rho_p(x)\rho_{\delta_x(p)}(\textbf{u})
  \end{align*}

  On définit le \textbf{semi-groupe d'automate engendré par $\mathcal{A}$} comme
  \begin{equation*}
    \left<\mathcal{A}\right>_+=\left<\rho_p, \forall p\in\mathcal{Q}\right>
  \end{equation*}

  Si l'automate $\mathcal{A}$ est inversible, alors on peut aussi considérer l'inverse des $\rho_p$. Dans ce cas, l'automate engendre un groupe noté $\left<\mathcal{A}\right>$.

\end{definition}

\begin{prop}{\cite{DBLP:journals/corr/abs-1105-4725}}
  \label{prop:finitude-d}
  Soit $\mathcal{A}$ un automate de Mealy. $\left<\mathcal{A}\right>$ est fini si et seulement si $\left<\mathfrak{d}\mathcal{A}\right>$ est fini.
\end{prop}

\begin{prop}{\cite{DBLP:journals/corr/abs-1105-4725}}
  \label{prop:finitude-m}
  Soit $\mathcal{A}$ un automate de Mealy, alors
  \[ \left<\mathfrak{m}\mathcal{A}\right> = \left<\mathcal{A}\right>. \]
\end{prop}

Des proposition \ref{prop:finitude-d} et \ref{prop:finitude-m} on déduit la proposition suivante.

\begin{prop}
  \label{prop:md-trivial}
  Un automate de Mealy engendre un groupe fini si et seulement si son $\mathfrak{md}$-réduit engendre un groupe fini.
\end{prop}

\begin{prop}
  Tout automate $\mathfrak{md}$-trivial engendre un groupe fini.
\end{prop}

La réciproque est fausse en général. Il semble pourtant que dans la classe particulière des automates biréversibles, la $\mathfrak{md}$-réduction est efficace.

\begin{thm}(\citeauthor{Klimann13})
  \label{thm:K}
  Tout automate fini à deux lettres et/ou deux états engendre un groupe fini si et seulement s'il est $\mathfrak{md}$-trivial.
\end{thm}

Ce théorème ne se généralise pas aux biréversibles en général.

\begin{center}
  \begin{figure}[h]
    ====> INSERER FANTASTIQUE TIKZ <====
    \caption{Contre exemple à une génélisation du théorème \ref{thm:K}, aka Les 4 fantastiques}
  \end{figure}
\end{center}


Ces contres exemples sont pourtant factorisables, et en conjugant leur factorisation, on trouve un automate $\mathfrak{md}$-trivial. Ce qui nous conduit à la conjecture suivante.

\begin{conj}
  \label{conj:birev-mdc}
  Un automate de Mealy biréversible engendre un groupe fini si et seulement si son $\mathfrak{mdc}$-réduit est trivial.
\end{conj}

Cette conjecture est l'objet des recherches ménées au cours de ce projet.

\begin{prop}
  \label{prop:finitude-c}
  Soient $\mathcal{A}, \mathcal{B}$ des automates de Mealy.
  $\mathcal{A}\mathcal{B}$ engendre un groupe fini si et seulement si $\mathcal{B}\mathcal{A}$ engendre un groupe fini.
\end{prop}

\begin{proof}
  Soient $\mathcal{A}=\left(\mathcal{Q}_1, \Sigma, \delta, \rho\right)$ et $\mathcal{B}=\left(\mathcal{Q}_2, \Sigma, \delta, \rho\right)$ des automates de Mealy sur un même alphabet.

  On suppose sans perte de généralité $\mathcal{Q}_1$ et $\mathcal{Q}_2$ disjoints. On écrit donc $\rho$ pour les deux automates sans ambiguïté.

  On suppose $\left<\mathcal{A}\mathcal{B}\right>$ fini.

  Tout élément de $\left<\mathcal{B}\mathcal{A}\right>$ est de la forme
  \[
    \rho_{p_1q_1}\circ\rho_{p_2q_2}\circ\cdots\circ\rho_{p_nq_n}
  \]
  où les $p_i$ sont des éléments de $\mathcal{Q}_2$ et les $q_i$ des éléments de $\mathcal{Q}_1$. Or
  \begin{align*}
    \rho_{p_1q_1}\circ\rho_{p_2q_2}\circ\cdots\circ\rho_{p_nq_n} &= \rho_{q_1}\circ\rho_{p_1}\circ\rho_{q_2}\circ\rho_{p_2}\circ\cdots\circ\rho_{q_n}\circ\rho_{p_n} \\
    &=\rho_{q_1}\circ\left(\rho_{p_1}\circ\rho_{q_2}\circ\rho_{p_2}\circ\cdots\circ\rho_{q_n}\right)\circ\rho_{p_n} \\
    &=\rho_{q_1}\circ\underbrace{\left(\rho_{q_2p_1}\circ\rho_{q_3p_2}\circ\cdots\circ\rho_{q_np_{n-1}}\right)}_{\in\left<\mathcal{A}\mathcal{B}\right>}\circ\rho_{p_n}
  \end{align*}

  On en déduit que tout élément de $\left<\mathcal{B}\mathcal{A}\right>$ s'écrit comme la composition d'un $\rho_{q},~q\in\mathcal{Q}_1$, d'un $\rho_\bullet\in\left<\mathcal{A}\mathcal{B}\right>$ et d'un $\rho_{p},~p\in\mathcal{Q}_2$. Or $\mathcal{Q}_1$ et $\mathcal{Q}_2$ sont finis, donc le nombre de choix de $p$ et de $q$ sont fini. De plus, on a supposé le nombre d'éléments $\rho_\bullet\in\left<\mathcal{A}\mathcal{B}\right>$ est fini. Donc le nombre d'élements qui s'écrivent \[ \rho_q\circ\rho_\bullet\circ\rho_p \] est fini. On a montré plus haut que tout éléments de $\left<\mathcal{B}\mathcal{A}\right>$ sont de cette forme, on en conclut qu'il y en a un nombre fini.

  $\mathcal{A}$ et $\mathcal{B}$ jouant des rôles complètement symétriques, la même démonstration marche pour montrer la réciproque.
\end{proof}

On déduit des propositions \ref{prop:finitude-d}, \ref{prop:finitude-m} et \ref{prop:finitude-c} une des implications de la conjecture \ref{conj:birev-mdc}.

\begin{prop}
  Tout automate de Mealy engendre un (semi)groupe fini si et seulement si son $\mathfrak{mdc}$-réduit engendre un (semi)groupe fini.
\end{prop}

\section{Génération et Factorisation d'automates de Mealy}
La génération et la factorisation d'automates de Mealy est un problème pour lequel aucune solution efficace n'existe pour l'instant. Dans le but de pouvoir infirmer ou consolider la conjecture \ref{conj:birev-mdc}, une partie de notre travail a été d'essayer de trouver et d'implémenter des méthodes de génération et de factorisation efficaces pour les automates de Mealy biréversibles.


\subsection{Clôture de classes d'automates}

Puisque nous nous interéssont à la classe des automates biréversibles, montrons qu'elle est bien close par les opérations qui nous interésse, ie. la dualisation, la minimisation, le produit et la factorisation.

\begin{prop}[Clôture des inversibles par produit]
  Soient $\mathcal{A}$ et $\mathcal{B}$ des automates de Mealy \textbf{inversibles}. Alors $\mathcal{A}\cdot\mathcal{B}$ est inversible
\end{prop}

\begin{proof}
  Soient $\mathcal{A}=\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ et $\mathcal{B}=\left(\mathcal{Q'}, \Sigma, \delta', \rho'\right)$ deux automates inversibles, et soit $\mathcal{A\cdot B}=\left(\mathcal{Q\times Q'}, \Sigma, \delta'', \rho''\right)$ leur produit.


  Considérons un état $(p, r)$ de ce produit. Alors $\rho_r\circ\rho'_p=\rho_{(p,r)}$, or puisque les automates $\mathcal{A}$ et $\mathcal{B}$ sont inversibles, $\rho_p$ et $\rho'_r$ sont des permutations du groupe de symétrie de $\Sigma$, on en déduit que $\rho_{(p, r)}$ en est une aussi.

  On a bien que tous les ${(\rho''_q)}_{q\in Q\times Q'}$ sont des permutations sur les lettres, c'est à dire que l'automate est inversible.
\end{proof}

\begin{prop}[Clôture des réversibles par produit]
  Soient $\mathcal{A}$ et $\mathcal{B}$ des automates de Mealy \textbf{réversibles}. Si $\mathcal{A}$ est \textbf{inversible}, alors $\mathcal{A}\cdot\mathcal{B}$ est réversible.
\end{prop}

\begin{proof}
  Soient $\mathcal{A}=\left(\mathcal{Q}, \Sigma, \delta, \rho\right)$ et $\mathcal{B}=\left(\mathcal{Q'}, \Sigma, \delta', \rho'\right)$ deux automates réversibles, et soit $\mathcal{A\cdot B}=\left(\mathcal{Q\times Q'}, \Sigma, \delta'', \rho''\right)$ leur produit.


  On suppose $\mathcal{A}$ inversible.


  Par définition $\delta''_x(pr)=(\delta_x(p), \delta'_{\rho_p(x)}(r))$. Or, puisque les automates sont réversibles, les $(\delta_x)_{x\in\Sigma}$ et ${(\delta'_x)}_{x\in\Sigma}$ sont des bijections. De plus, $\mathcal{A}$ esr inversible donc les ${(\rho_p)}_{p\in \mathcal{Q}}$ sont des bijections. On en conclut que les ${(\delta''_{pr})}_{pr\in\mathcal{Q}\times\mathcal{Q'}}$ sont aussi des bijections.
\end{proof}

\begin{prop}[Clôture des biréversibles par produit]
  Soient $\mathcal{A}$ et $\mathcal{B}$ des automates \textbf{biréversibles}, alors $\mathcal{A}\cdot\mathcal{B}$ est \textbf{biréversible}.
\end{prop}

\begin{prop}[Clôture des inversibles par facteurs]\label{prop_cloture_inv_facteurs}
  Soit $\mathcal{A}$ un automate de Mealy \textbf{inversible} qui se factorise en deux automates $\mathcal{A}_1$ et $\mathcal{A}_2$. Alors ces deux automates sont aussi inversibles.
\end{prop}

\begin{proof}
  Soient $\mathcal{A}=\left(\mathcal{Q\cdot Q'}, \Sigma, \delta, \rho\right)$, $\mathcal{A}_1=\left(\mathcal{Q}, \Sigma, \delta', \rho'\right)$ et $\mathcal{A}_2=\left(\mathcal{Q'}, \Sigma, \delta'', \rho''\right)$ tel que ci dessus.

  Pour chaque état $(p, r)$ de $\mathcal{A}$, $\rho_{(p, r)}\in S(\Sigma)$. Comme $\mathcal{A}=\mathcal{A}_1\cdot\mathcal{A}_2$, on a l'égalité $\rho_{(p, r)}=\rho'_r\circ\rho''_p$. Puisque $\rho_{(p, r)}$ est une permutation, on en déduit que $\rho'_p$ et $\rho''_r$ en sont aussi, d'où le résultat.
\end{proof}

\begin{prop}\label{prop_inverse_produit}
    Soit $\mathcal{A}$ un automate de Mealy \textbf{inversible} qui se factorise en deux automates $\mathcal{A}_1$ et $\mathcal{A}_2$.
    Alors $\mathcal{A}^{-1} = \mathcal{A}_2^{-1} \cdot \mathcal{A}_1^{-1}$.
\end{prop}

\begin{proof}
  TODO
\end{proof}

\begin{prop}[Clôture des réversibles par facteurs]\label{prop_cloture_rev_facteurs}
  Soit $\mathcal{A}$ un automate de Mealy \textbf{réversible} qui se factorise en deux automates $\mathcal{A}_1$ et $\mathcal{A}_2$. Alors
  \begin{itemize}
  \item $\mathcal{A}_1$ est réversible.
  \item si $\mathcal{A}_1$ est inversible, alors $\mathcal{A}_2$ est réversible.
  \end{itemize}
\end{prop}

\begin{proof}
  Soient $\mathcal{A}=\left(\mathcal{Q\cdot Q'}, \Sigma, \delta, \rho\right)$ réversible, $\mathcal{A}_1=\left(\mathcal{Q}, \Sigma, \delta', \rho'\right)$ et $\mathcal{A}_2=\left(\mathcal{Q'}, \Sigma, \delta'', \rho''\right)$ tels que $\mathcal{A} = \mathcal{A}_1\cdot\mathcal{A}_2$.

  Par définition, on a que $\delta_x(pr) = (\delta'_x(p), \delta''_{\rho'_p(x)}(r))$. Les ${(\delta_x)}_{x\in\Sigma}$ sont inversibles, alors il est clair les ${(\delta'_x)}_{x\in\Sigma}$ sont inversibles.

  De plus, chacun des $\delta''_{\rho_p(x)}$ est inversibles, donc si $\mathcal{A}_1$ est inversible, les ${(\rho_p)}_{p\in\Sigma}$ étant inversibles, alors tous les ${(\delta''_x)}_{x\in\Sigma}$ sont inversibles. D'où $\mathcal{A}_2$ est réversible.
\end{proof}

\begin{prop}[Clôture des biréversibles par facteurs]
  Soit $\mathcal{A}$ un automate \textbf{biréversible} et $\mathcal{A}_1$, $\mathcal{A}_2$ des automates tels que $\mathcal{A}=\mathcal{A}_1\cdot\mathcal{A}_2$, alors $\mathcal{A}_1$ et $\mathcal{A}_2$ sont biréversible.
\end{prop}

\begin{proof}
    $\mathcal{A}$ est biréversible, donc en particulier $\mathcal{A}$ est inversible et réversible. D'après la proposition \ref{prop_cloture_inv_facteurs}, $\mathcal{A}_1$ et $\mathcal{A}_2$ sont inversibles. Puisque $\mathcal{A}_1$ est inversible, d'après la proposition \ref{prop_cloture_rev_facteurs}, $\mathcal{A}_1$ et $\mathcal{A}_2$ sont réversibles.

    D'après la proposition \ref{prop_inverse_produit}, $\mathcal{A}^{-1} = \mathcal{A}_2^{-1} \cdot \mathcal{A}_1^{-1}$. Or $\mathcal{A}^{-1}$ est réversible puisque $\mathcal{A}$ est biréversible. Donc, toujours d'après la proposition \ref{prop_cloture_rev_facteurs} et puisque $\mathcal{A}_1^{-1}$ est inversible, $\mathcal{A}_1^{-1}$ et $\mathcal{A}_2^{-1}$ sont réversibles.

    Ainsi, $\mathcal{A}_1$ et $\mathcal{A}_2$ sont bien biréversibles.
\end{proof}

\subsection{Algorithme de génération des biréversibles\label{sec:gen}}

\subsubsection*{L'algorithme}
Notre algorithme de génération se base sur le résultat suivant de \cite{DBLP:journals/corr/abs-1105-4725}

\begin{thm}
  \label{thm:ir-helix}
  Soit $\mathcal{A}$ un automate de Mealy inversible réversible. Les propositions suivantes sont équivalentes

  \begin{enumerate}[(i)]
  \item $\mathcal{A}$ est biréversible
  \item Le graphe en hélice de $\mathcal{A}$ est une union de cycles disjoints.
  \end{enumerate}
\end{thm}

Notre algorithme procède donc à la recherche exhaustive de toutes les machines de Mealy inversibles réversibles en maintenant la contrainte que le graphe en hélice est une union de cycles disjoints.

\subsubsection*{À isomorphisme près}

On a rapidement constaté que le nombre d'automates a générer est très important. Aussi, il ne semble pas réaliste de tester la $\mathfrak{mdc}$-réduction sur tout ceux-ci. On a donc cherché à extraire seulement les classes d'isomorphismes de notre génération.

M. Picantin nous a parlé de la bibliothèque de graphe \textrm{Nauty} qui est, semble-t'il, la plus efficace. Il a fallu s'assurer que les morphismes de \textit{graphe} trouvé par \textrm{Nauty} corresponde bien à des morphismes de \textit{machine de Mealy}. Nous avons donc utilisé ce que nous appellons \textit{\textbf{le graphe en hélice augmenté}}: le graphe en hélice auquel nous ajoutons des sommets pour chaque état et chaque lettre de l'automate et les relions à ceux qu'ils étiquettent.

\begin{center}
  \begin{figure}[h]
    ====> INSERER GRAPHE EN HELICE AUGMENTE TIKZ <====
    \caption{graphe en hélice augmenté de l'automate xx}
  \end{figure}
\end{center}

Pour calculer les isomorphismes entre les graphes \textrm{Nauty} associe à un graphe \textit{\textbf{une forme canonique}}, ie. un graphe représentant de sa classe d'isomorphisme. Nous prenons donc comme représentant des classes d'isomorphismes de machine de Mealy celles sont une forme canonique au sens de \textrm{Nauty}. Lors de la génération nous nous contentons de calculer la forme canonique du graphe en hélice augmenté puis de tester s'il laisse les lettres et les états inchangés. Auquel cas, il est canonique.

Nauty permet de préciser des classes d'équivalence sur les sommets du graphe qui doivent êtres préservés lors du passage à la forme canonique. Les sommets correspondants aux états, aux lettres et au graphe en hélice simple représente trois classes qui ne doivent pas être mélangées les unes avec les autres par \textrm{Nauty}.

\subsubsection*{Quelques optimisations conséquentes}
Nous avions commencé par implémenter la génération en \textrm{Python} mais nous avions trois inconvénients majeurs
\begin{itemize}
\item La complexité en mémoire: l'énorme quantité de machines à générer fait très vite exploser la \textrm{RAM} de l'ordinateur\footnote{Plus tard nous arrivions finalement à obtenir un fichier de 31 gigas octets contenant tous les automates biréversibles à 4 états et 4 lettres} sans qu'on puisse bien la contrôler en Python.
\item La complexité en temps.
\item \textrm{Nauty} ne dispose pas d'interface efficace en python.
\end{itemize}

Nous avons donc décidé d'implémenter une version C beaucoup plus efficace.

Le test de la forme canonique ne nécessitant le parcours d'aucune structure de donnée globale au programme, il a été très facile de le parallèlliser.

\subsubsection*{Quelques benchmarks}

\begin{center}
  \begin{table}[h!]
    \begin{threeparttable}
    \begin{tabular}{|rrrrrr|}
      \hline
      \#états & \#lettres & 1 & 2 & 3 & \#biréversibles \\ [0.5ex]
      \hline\hline
      2 & 2 & 0.002s & 0.003s & 0.004s & 12 \\
      \hline
      3 & 2 & 0.003s & 0.003s & 0.002s & 144 \\
      \hline
      3 & 3 & 0.011s & 0.086s & 0.005s & 8 784 \\
      \hline
      4 & 3 & 0.830s & 28.018s & 0.368s & 1 092 096 \\
      \hline
      4 & 4 & 24:06.15s & trop long & 11:16.96s & 1 031 000 000 \\
      \hline
    \end{tabular}

    \caption{Benchmark génération d'automates biréversibles}
    \begin{tablenotes}
    \item[1] Temps sans nauty sans fork
    \item[2] Temps avec nauty sans fork
    \item[3] Temps sans nauty avec fork
    \end{tablenotes}
\end{threeparttable}
  \end{table}
\end{center}

\subsection{Algorithme de factorisation}

  Notons $\matcal{Q}$ les états de $\mathcal{A}$, $\mathcal{Q'}$ les états de $\mathcal{B}$ et $\mathcal{Q''}$ les états de $\mathcal{M}$. On remarque que tel qu'a été définit le produit (définition \ref{def:produit}) les états de $\mathcal{AB}$ sont des éléments de $\mathcal{Q}\times\mathcal{Q'}$.

Or quand on factorise un automate, l'ensemble de ses états n'apparait pas comme un produit d'ensemble. Aussi faut-il choisir une manière canonique de construire une bijection $\iota$ de $\mathcal{Q''}$ dans $\mathcal{Q}\times\mathcal{Q'}$ qui représente cette correspondance. Il est clair que si une telle bijection n'existe pas -- c'est à dire si $|\mathcal{Q}''| \ne |\mathcal{Q}|\times|\mathcal{Q'}|$ -- l'automate $\mathcal{M}$ n'est pas factorisable par $\mathcal{A}$ et $\mathcal{B}$.

Quand on cherchera à factoriser un automate $\mathcal{M}$ dont les états sont $\mathcal{Q}$, on identifira ses états à $\iota(\mathcal{Q})$ un produit d'ensemble.

\begin{figure}[h!]
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \draw [->] (-0.5, 0) node[left] {p} to (0.5, 0) node[right] {q};
      \draw [->] (0, 0.5) node[above] {x} to (0, -0.5) node[below] {y};
    \end{tikzpicture}
    \caption{Une flèche de l'automate $\mathcal{M}$}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \draw [->] (-0.5, 1) node[left] {$p_0$} to (0.5, 1) node[right] {$q_0$};
      \draw [->] (0, 1.5) node[above] {x} to (0, 0.5);

      \draw [->] (-0.5, -0.5) node[left] {$p_1$} to (0.5, -0.5) node[right] {$q_1$};
      \draw [->] (0, 0) node[above] {z} to (0, -1) node[below] {y};
    \end{tikzpicture}
    \caption{En haut l'automate $\mathcal{A}$ et en bas $\mathcal{B}$\label{fig:factor-ab}}
  \end{subfigure}
  \caption{Correspondance entre les flèches dans $\mathcal{M}$ et celles de $\mathcal{A}$ et $\mathcal{B}$. Ici on a que $\iota(p) = (p_0,~p_1)$ et $\iota(q)=(q_0, q_1)$\label{fig:facto}}
\end{figure}

On remarque alors, que connaissant $\mathcal{M}$, la seule donnée inconnue de la figure \ref{fig:factor-ab} est le $z$. Notre algorithme de factorisation consiste donc à essayer tout les $z$ possible pour chaque arrête de $\mathcal{M}$ pour chaque couple de diviseur du nombre d'états de $\mathcal{M}$. On construit ainsi toutes les flèches des facteurs.

On peut borner grossièrement la complexité en temps de l'algorithme par $\mathcal{O}(|\mathcal{Q''}|^2|\Sigma|^2)$. Ce qui est une complexité satisfaisante par rapport à celle de nos autres algorithmes.

\section{Avancées sur le problème de finitude}

\section{Conclusions}

\newpage
\bibliography{project}{
  \nocite{*}
}
\bibliographystyle{plain}

\end{document}
